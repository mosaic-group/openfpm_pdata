test fork commit
* Try to install OpenFPM I get "cannot recover from this error"
It mean that the configuration phase has failed. Something has failed, what has failed should be reported some line before. We are trying to track the causes to understand if it is possible to produce a better error message but it seem that most of the time this error has been seen on OSX having a very old X-Code.

* I get a huge number of error
It can happen in compilation phase. The installation system in general should detect potential known incompatibility and try in the best case to silently workaround the problem, in the middle case provide an automatic solution and ask to the user the permission to perform it, in the worst case report to the user for manual fixation. Unfortunately the number of systems and possible configuration/missconfiguration make this task impossible to control.

* The program generate the file openfpm_vars in my "holy" home folder. why ?
If you show the hidden folder in your "holy" home, you will see how many program actually "violate" your home folder. They do costantly Creating/Reading/Writing such folder every time you open them, they are just hiding. OpenFPM create such text file only one time in installation and report it, mooving such file somewhere else after installation will bring the home folder to be "virgin" from OpenFPM forever.

* The examples does not scale on my 4 - x core PC.
Not all examples are made for scalability. In particular example that do not have computation inside like the 0_simple_ ... . If instead is an example that has computation inside, when you are benchmarking in particular using all the cores of your PC, close all applications, like Browser, IDE, pdf reader, ..., unusefull shell running command (anything that could consume resources, consider that the Desktop environment consume resources, in particular if you have OpenGL/3D effects, disable them. The best would be close the X-server/Desktop environment). Check also that no program are running in background using resources, use top/Task manager to check this. Consider also that 99.9% of Laptop/Desktop today can adjust their frequency dynamically. In particular it is common that the system increase the CPU frequency at higher level when only one-core is used compared to N-core, and this can significantly affect scalability. Another potential scalability problem is given by the memory bandwidth. Some of the examples can exaust your memory bandwidth and once is saturated increare the core counting does not improve. Consider (in late 2018) main-stream CPUs 2 two memory channels for 4 o 6 cores, while high end cpus has 4 memory channels but can have 16 or more cores. High end server grade cpus like Xeon has 4 or 6 memory channels but they can have 20 or more cores. while 8 channels are probably in the near future
 
